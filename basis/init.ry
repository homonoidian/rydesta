; *** init.ry ***
; - This file gets auto-imported into every Rydesta script. Here, all out-of-the-box
; features are defined.
; - Beware of the "order" of infix and prefix definitions: some infixes/prefixes
; are closer to the builtins than others; also, we're closures, so if we depend
; on a function, it must exist beforehand.
; === ALEXEY YURCHENKO, 2020

;; === OPERATORS ================================

; --- Identity unary ----------------------------

'not (false) -> true
'not _ -> false

; --- Precedences -------------------------------

PRECEDENCE_TERNARY = 1
PRECEDENCE_JUNCTION = 2
PRECEDENCE_IDENTITY = 3
PRECEDENCE_ADD = 4
PRECEDENCE_MUL = 5

; Guards should operate on identity level.
#:set-guard-precedence PRECEDENCE_IDENTITY

; --- Ternary when-else -------------------------

#:set-precedence PRECEDENCE_TERNARY

; say "true" when true ==> OUT: true
; say "false" when false ==> false
quoting 'when conseq cond ->
  case unquote cond {
    false => false
    _ -> unquote conseq
  }

; 1 else 2 ==> 1
; false else "quux" ==> "quux"
quoting 'else cond conseq -> {
  val = unquote cond
  if not val {
    unquote conseq
  } else {
    val
  }
}

; --- Identity ----------------------------------

#:set-precedence PRECEDENCE_IDENTITY

; "hello" is "hello" ==> true
; 1 is 2 ==> false
; 1 is not 2 ==> true
; TODO: compare instances?
'is _ _ -> false
'is left (left) -> true
'is_not left right -> not (left is right)

; 1 of "hello" ==> false
; [1 2 3] of vec ==> true
; TODO: T may be a vector of types
'of value T -> {
  ; T has attribute `type` and its value is `type` => a type was given
  ; Using equals? here since `is` doesn't know how to equal Python objects.
  ; Note that #:getattr returns false when attribute was not found.
  if #:equals? (#:getattr T "type") (#:getattr "type" "value") {
    ; Each type's value is a Python string of typename (see master, kernel).
    ; each value's type is a Python string (see children of _Box etc. of machine).
    if #:equals? (#:getattr value "type") (#:getattr T "value") {
      ret true
    }
  }
  false
}
'not_of value T -> not (value of T)

; --- Junctions ---------------------------------

#:set-precedence PRECEDENCE_JUNCTION

; 1 and 2 ==> 2
; "hello" and "david" ==> "david"
; false and say "hello" ==> false
; true and say "hello" ==> OUT: hello
; 1 or 2 ==> 1
; false or "baz" ==> "baz"
; true or say "hello" ==> true
; false or say "hello" ==> OUT: hello
for left right {
  quoting 'and -> {
    value = unquote left
    case value {
      false => value
      _ -> unquote right
    }
  }
  quoting 'or -> {
    value = unquote left
    case value {
      false => unquote right
      _ -> value
    }
  }
}

; --- Helpers -----------------------------------
; At this point we can define a bunch of nice helpers.

obj _HelperObj {
  operation (return-of of str) (operator of str) (args of vec) ->
    #:kernel-glob-call return-of [(#:from-operator operator args)]

  to-python-int (number of num) ->
    #:kernel-builtin-call "int" [(#:getattr number "value")]
}

_H = new _HelperObj

; --- And back to identity! ---------------------

#:set-precedence PRECEDENCE_IDENTITY

; [1 2 3] are of num ==> true
'are_of [] _ -> false
'are_of [item] T -> item of T
'are_of [item rest+] T -> item of T and rest are of T
'are_not_of values T -> not (values are of T)

; [3 3 3] are 3 ==> true
; [3 4 5] are 5 ==> false
'are [] _ -> false
'are [item] value -> item is value
'are [item rest+] value -> item is value and rest are value
'are_not values value -> not (values are value)

; 1 in [1 2 3] ==> true
; [1 2 3] in [[1 2 3] [4 5 6]] ==> true
; [] in [[]] ==> true
; 1 in [] ==> false
'in _ [] -> false
'in entity [item] -> entity is item
'in entity [item rest+] -> entity is item or entity in rest
'not_in entity items -> not (entity in items)

; --- Operations --------------------------------

; Addition-level.

#:set-precedence PRECEDENCE_ADD

; "foo" + "bar" ==> "foobar"
for (left of str) (right of str) {
  '+ -> _H.operation "RyStr" "add" [left right]
}

; 1234 + 5678 ==> 6912
; 1234 - 5678 ==> -4444
; .1 + .2 ==> 0.3
for (left of num) (right of num) {
  '+ -> _H.operation "RyNum" "add" [left right]
  '- -> _H.operation "RyNum" "sub" [left right]
}

; Multiplication-level.

#:set-precedence PRECEDENCE_MUL

; "foo" * 3 ==> "foofoofoo"
'* (left of str) (right of num) ->
  _H.operation "RyStr" "mul" [left (_H.to-python-int right)]

; [0] * 100 => [0 0 0 ...]
'* (left of vec) (right of num) ->
  _H.operation "RyVec" "mul" [left (_H.to-python-int right)]

; 2 * 2 ==> 4
; 2 / 2 ==> 1
for (left of num) (right of num) {
  '* -> _H.operation "RyNum" "mul" [left right]
  '/ -> _H.operation "RyNum" "truediv" [left right]
}

; +1234 ==> 1234
; -1234 ==> -1234
for (operand of num) {
  ; XXX '+ doesn't really change anything, does it?
  '+ -> operand
  '- -> 0 - operand
}

; Leave precedence on addition's level.
#:set-precedence PRECEDENCE_ADD

;; === I/O ================================

say entity ->
  ; say returns None; None is not `false` in Rydesta.
  #:print entity and entity
